<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Introdução on Relatório Redes III</title><link>https://gobbedu.github.io/Secure-KVS/</link><description>Recent content in Introdução on Relatório Redes III</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Thu, 23 Feb 2023 10:18:19 -0300</lastBuildDate><atom:link href="https://gobbedu.github.io/Secure-KVS/index.xml" rel="self" type="application/rss+xml"/><item><title>Log</title><link>https://gobbedu.github.io/Secure-KVS/docs/kvs-seguro/log/</link><pubDate>Thu, 23 Feb 2023 10:18:19 -0300</pubDate><guid>https://gobbedu.github.io/Secure-KVS/docs/kvs-seguro/log/</guid><description>Arquivo Log # Abaixo temos o Log de execução tanto do servidor quanto do cliente, para a execução com as flags --show e/ou --edit para cada um deles. Client --show # Da mesma forma, com o servidor rodando, ao executar python client.py --show podemos visualizar não só a interação com a KVS shell, mas também podemos ver o tráfego sendo enviado pelo cliente usando ssl (o trafego recebido pode ser visto no log de envio do server).</description></item><item><title/><link>https://gobbedu.github.io/Secure-KVS/docs/kvs-seguro/base-de-dados/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://gobbedu.github.io/Secure-KVS/docs/kvs-seguro/base-de-dados/</guid><description>Base de Dados # Key Value Store - KVS # Um sistema KVS (Key-Value Store) ou Armazenamento Chave-Valor é um tipo de banco de dados que armazena e recupera dados usando um modelo simples de pares de chave e valor. Nesse tipo de sistema, cada dado é associado a uma chave única e essas chaves são usadas para recuperar os valores correspondentes. Um KVS não impõe nenhum esquema ou estrutura de dados específica, permitindo armazenar qualquer tipo de dado, como strings, números, objetos serializados, entre outros.</description></item><item><title/><link>https://gobbedu.github.io/Secure-KVS/docs/kvs-seguro/cliente/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://gobbedu.github.io/Secure-KVS/docs/kvs-seguro/cliente/</guid><description>Cliente KVS # Responsável por enviar comandos CRUD ao servidor e mostrar o resultado de suas operações. Não possui acesso ao banco de dados, apenas se comunicando com o servidor. Execução # Com o servidor rodando e após executar:
python client.py Podemos acessar a interface cmd.Cmd e interagir com o Key Value Store (KVS), onde a mensagem de boas vindas pode ser vista abaixo:
Introdução cliente Bem-vindo ao shell do Key-Value Store.</description></item><item><title/><link>https://gobbedu.github.io/Secure-KVS/docs/kvs-seguro/inspecion%C3%A1vel/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://gobbedu.github.io/Secure-KVS/docs/kvs-seguro/inspecion%C3%A1vel/</guid><description>Socket Inspecionável # Esta página explica como funciona o código presente em inspectable.py encontrado neste repositório e utilizado durante a prova de Sigilo e Integridade do sistema implementado. MemoryBIO # A documentação para os detalhes da biblioteca utilizada podem ser encontrados na página do ssl abaixo:
https://docs.python.org/3/library/ssl.html#memory-bio-support Nela é descrito que o objeto ssl (SSLObject) foi criado como uma versão de mais baixo nível em relação ao SSLSocket com o intuito de realizar operações de Input e Output (IO) assíncronas.</description></item><item><title/><link>https://gobbedu.github.io/Secure-KVS/docs/kvs-seguro/servidor/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://gobbedu.github.io/Secure-KVS/docs/kvs-seguro/servidor/</guid><description>Servidor KVS # Responsável por receber comandos CRUD de um cliente autenticado e executá-los no banco de dados, enviando o resultado das operações de volta para o cliente. Tem acesso ao banco de dados, podendo se comunicar com um cliente somente uma vez. Execução # Para inicializar o servidor basta executar
python server.py A partir de então o servidor fica na escuta por conexões e ao receber uma, executa as operações solicitadas até que o comando exit seja enviado, ou que o processo seja terminado com um Ctrl + C.</description></item></channel></rss>